{% extends "upbase.html" %}
{% block title %}
 Ds. & Algo.
{% endblock title %}
{% block body %}
{% if user.is_authenticated %}

<!-- header section ends -->

<div id="menu" class="fas fa-bars"></div>

<!-- home section starts  -->


   
<div style="margin: 2%;"><div class="head_cheat3">All Data structure & Algoritham cheat sheet below here...</div>

<!-- contact section ends -->
<div style="margin:2%;">

 <b class="tit">
Program 1:ADTs in array create,insert,display program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct myarr{
  int total_size;
  int use_size;
  int *ptr;
};
void creatarr(struct myarr *a,int tsize,int usize)
{
  a-&gt;total_size=tsize;
  a-&gt;use_size=usize;
  a-&gt;ptr=(int*)malloc(tsize*sizeof(int));
}

void setval(struct myarr *a)
{
  int i,n;
  for(i=0;i&lt;a-&gt;use_size;i++)
  {
  printf("Enter the %d position data=",i);
  scanf("%d",&n);
  a-&gt;ptr[i]=n;
  }
  
}
void show(struct myarr *a)
{
    int i;
  for(i=0;i&lt;a-&gt;use_size;i++)
  {
    printf("%d",a-&gt;ptr[i]);
    printf("\n");
  }
}
int main()
{
  struct myarr marks;
  creatarr(&marks,10,3);
  setval(&marks);
    printf("Display the inseted data=\n");
  show(&marks);
return 0;
}</code></pre></br></br>

<b class="tit">
Program 2:Insertion in array.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void displayarr(int arr[],int n)
{ int i;
    
  for(i=0;i&lt;n;i++)
  {
    printf("%d\n",arr[i]);
  }
}
int indinsertion(int arr[],int n,int capacity,int index,int element)
{
  if(n&gt;=capacity)
  {
    return -1;
  }

  int i;
  for(i=n-1;i&gt;=index;i--)
  {
    arr[i+1]=arr[i];
  }
    arr[index]=element;
    return 1;
  
}
int main()
{
  int arr[100]={5,14,52,61,83};
  int size=5,index=1,element=45;
  printf("Before the insertion=\n");
  displayarr(arr,size);
  indinsertion(arr,size,100,index,element);
  size+=1;
  printf("After the insertion=\n");
  displayarr(arr,size);
return 0;
}
</code></pre></br></br> 

<b class="tit">
Program 3:Deletion in array.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void display(int arr[],int size)
{ 
  int i;
  for(i=0;i&lt;size;i++)
  {
    printf("%d\n",arr[i]);
  }
}
int deletionarr(int arr[],int size,int index)
{
  int i;
  for(i=index;i&lt;size-1;i++)
  {
    arr[i]=arr[i+1];
  }
  return 1;
}
int main()
{
  int arr[100]={1,5,9,23,94};
  int size=5,index=0;
  printf("Before the deletion\n");
  display(arr,size);
  deletionarr(arr,size,index);
  size-=1;
  printf("After the deletion\n");
  display(arr,size);
return 0;
}</code></pre></br></br>

<b class="tit">
Program 4:Linear searching.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
int linearsearch(int arr[],int size,int element)
{
  int i;
  for(i=0;i&lt;size;i++)
  {
    if(arr[i]==element)
    {
      return i;
    }
  }
  return -1;
}
int main()
{
  int arr[100]={1,32,52,2,92};
  int size=sizeof(arr)/sizeof(int);
  int element=2;
  
  printf("This element %d is %d index",element,linearsearch(arr,size,element));
return 0;
}</code></pre></br></br> 

<b class="tit">
Program 5:Binary searching.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
int binarysearch(int arr[],int size,int element)
{
  int low,high,mid;
  low=0;
  high=size-1;
  while(low&lt;=high)
  {
    mid=(low+high)/2;
    if(arr[mid]==element)
    {
      return mid;
      } 
      if(arr[mid]&lt;element)
      {
        low=mid+1;
      }
      else
      {
        high=mid-1;
      }
  }
return -1;
}
int main()
{
  int arr[]={1,5,22,52,115};
  int size=sizeof(arr)/sizeof(int);
  int element=22;
  printf("this element %d is the %d position",element,binarysearch(arr,size,element));
return 0;
}</code></pre></br></br> 

<b class="tit">
Program 6:Creation & traversal in linked list.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
  int data;
  struct node *next;
};
void linkedtraversal(struct node *ptr)
{
  while(ptr != NULL)
  {
    printf("All Element in Linked List=%d\n",ptr-&gt;data);
    ptr=ptr-&gt;next;
  }
}
int main()
{
struct node *head,*second,*third;
head=(struct node*)malloc(sizeof(struct node));
second=(struct node*)malloc(sizeof(struct node));
third=(struct node*)malloc(sizeof(struct node));

head-&gt;data=5;
head-&gt;next=second;

second-&gt;data=35;
second-&gt;next=third;

third-&gt;data=65;
third-&gt;next=NULL;

linkedtraversal(head);
return 0;
}</code></pre></br></br>

<b class="tit">
Program 7:Insertion for all posibility in linked list.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
  int data;
  struct node *next;
};
void linkedtraversal(struct node *ptr)
{
  while(ptr != NULL)
  {
    printf("All Element in Linked List=%d\n",ptr-&gt;data);
    ptr=ptr-&gt;next;
  }
}
struct node *linkedatbegin(struct node *head,int data)
{
  struct node *ptr=(struct node*)malloc(sizeof(struct node));
  ptr-&gt;data=data;
  ptr-&gt;next=head;
  return ptr;
  
}
struct node *linkedatindex(struct node *head,int data,int index)
{
  struct node *ptr=(struct node*)malloc(sizeof(struct node));
  struct node *p=head;
  int i=0;
  while(i != index-1)
  {
    p=p-&gt;next;
    i++;
  }
  ptr-&gt;data=data;
  ptr-&gt;next=p-&gt;next;
  p-&gt;next=ptr;
  return head;
  
}
struct node *linkedatend(struct node *head,int data)
{
  struct node *ptr=(struct node*)malloc(sizeof(struct node));
  struct node *p=head;
  
  while(p-&gt;next!=NULL)
  {
    p=p-&gt;next;
  }
  ptr-&gt;next=NULL;
  p-&gt;next=ptr;
  ptr-&gt;data=data;
  return head;
}
struct node *linkedatafter(struct node *head,struct node *prevnode,int data)
{
  struct node *ptr=(struct node*)malloc(sizeof(struct node));

  ptr-&gt;next=prevnode-&gt;next;
  prevnode-&gt;next=ptr;
  ptr-&gt;data=data;
  return head;
}
int main()
{
struct node *head,*second,*third;
head=(struct node*)malloc(sizeof(struct node));
second=(struct node*)malloc(sizeof(struct node));
third=(struct node*)malloc(sizeof(struct node));

head-&gt;data=5;
head-&gt;next=second;

second-&gt;data=35;
second-&gt;next=third;

third-&gt;data=65;
third-&gt;next=NULL;

linkedtraversal(head);
//head=linkedatbegin(head,24);
//printf("After the Insertion=\n");
//linkedtraversal(head);
//head=linkedatindex(head,24,2);
//printf("After the Insertion=\n");
//linkedtraversal(head);
//head=linkedatend(head,20);
//printf("After the Insertion=\n");
//linkedtraversal(head);
head=linkedatafter(head,second,20);
printf("After the Insertion=\n");
linkedtraversal(head);
return 0;

}</code></pre></br></br> 

<b class="tit">
Program 8:Deletion for all posibility in linked list.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
  int data;
  struct node *next;
};
void linkedtraversal(struct node *ptr)
{
  while(ptr != NULL)
  {
    printf("All Element in Linked List=%d\n",ptr-&gt;data);
    ptr=ptr-&gt;next;
  }
}
struct node *deletebegin(struct node *head)
{
  struct node *ptr=head;
  head=head-&gt;next;
  free(ptr);
  return head;
}
struct node *deleteatindex(struct node *head,int index)
{
  struct node *p=head;
  struct node *q=head-&gt;next;
  int i=0;
  while(i!=index-1)
  {
    p=p-&gt;next;
    q=q-&gt;next;
  }
  p-&gt;next=q-&gt;next;
  free(q);
  return head;
}
struct node *deletelast(struct node *head)
{
  struct node *p=head;
  struct node *q=head-&gt;next;
  
  while(q-&gt;next!=NULL)
  {
    p=p-&gt;next;
    q=q-&gt;next;
  }
  p-&gt;next=NULL;
  free(q);
  return head;
}
struct node *deleteafter(struct node *head,int data)
{
  struct node *p=head;
  struct node *q=head-&gt;next;
  int i=0;
  while(q-&gt;data!=data && q-&gt;next!=NULL)
  {
    p=p-&gt;next;
    q=q-&gt;next;
  }
  if(q-&gt;data==data){
  
  p-&gt;next=q-&gt;next;
  free(q);
}
  return head;
}
int main()

{
struct node *head,*second,*third;
head=(struct node*)malloc(sizeof(struct node));
second=(struct node*)malloc(sizeof(struct node));
third=(struct node*)malloc(sizeof(struct node));

head-&gt;data=5;
head-&gt;next=second;

second-&gt;data=35;
second-&gt;next=third;

third-&gt;data=65;
third-&gt;next=NULL;
printf("Before Deletion=\n");
linkedtraversal(head);
//head=deletebegin(head);
//printf("After Deletion=\n");
//linkedtraversal(head);
//head=deleteatindex(head,1);
//printf("After Deletion=\n");
//linkedtraversal(head);
//head=deletelast(head);
//printf("After Deletion=\n");
//linkedtraversal(head);
head=deleteafter(head,5);
printf("After Deletion=\n");
linkedtraversal(head);
return 0;

}</code></pre></br></br> 

<b class="tit">
Program 9:Display circular(continues) linked list.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
  int data;
  struct node *next;
};
void contilinkedtraversal(struct node *head)
{
  struct node *ptr=head;
  do{
    printf("All Element in Linked List=%d\n",ptr-&gt;data);
    ptr=ptr-&gt;next;
  }while(ptr != head);

}
struct node *insertbegin(struct node *head,int data)
{
  
  struct node *ptr=(struct node*)malloc(sizeof(struct node));
  ptr-&gt;data=data;
  struct node *p=head-&gt;next;
  while(p-&gt;next!=head)
  {
  
    p=p-&gt;next;
  }
  p-&gt;next=ptr;
  ptr-&gt;next=head;
  head=ptr;
  return head;
}
int main()

{
struct node *head,*second,*third;
head=(struct node*)malloc(sizeof(struct node));
second=(struct node*)malloc(sizeof(struct node));
third=(struct node*)malloc(sizeof(struct node));

head-&gt;data=5;
head-&gt;next=second;

second-&gt;data=35;
second-&gt;next=third;

third-&gt;data=65;
third-&gt;next=head;

contilinkedtraversal(head);
head=insertbegin(head,12);
printf("AFter the insertion");
contilinkedtraversal(head);
return 0;

}</code></pre></br></br> 

<b class="tit">
Program 10:Doubly linked list.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
  int data;
  struct node *prev;
  struct node *next;
};
void doublylinked(struct node *head)
{
  struct node *ptr=head;
  while(ptr!=NULL)
  {
    printf("%d\n",ptr-&gt;data);
    ptr=ptr-&gt;next;
    
  } 
}
int main()
{
  struct node *head=(struct node*)malloc(sizeof(struct node));
  struct node *second=(struct node*)malloc(sizeof(struct node));
  struct node *third=(struct node*)malloc(sizeof(struct node)); 
  
  head-&gt;data=2;
  head-&gt;prev=NULL;
  head-&gt;next=second;
  
    second-&gt;data=4;
  second-&gt;prev=head;
  second-&gt;next=third;
  
    third-&gt;data=6;
  third-&gt;prev=second;
  third-&gt;next=NULL;

  doublylinked(head);
return 0;
}
</code></pre></br></br> 

<b class="tit">
Program 11:All stack operations like(empty(),full(),push(),pop(),peek(),stacktop(),stackbottom()).
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct stack{
  int size;
  int top;
  int *arr;
};
int empty(struct stack *ptr){
  if(ptr-&gt;top==-1)
  {
  
    return 1;
  }
  else{
    return 0;
  }
}
int full(struct stack *ptr){
  if(ptr-&gt;top==ptr-&gt;size-1)
  {
    return 1;
  }
  else{
    return 0;
  }
}
void push(struct stack *s,int value)
{ if(full(s))
  {
    printf("Stack is Overflow!");
  }
  else{
  
  s-&gt;top++;
  s-&gt;arr[s-&gt;top]=value;
}}
int pop(struct stack *s)
{
  if(empty(s))
  {
    printf("This stack is empty");
    return -1;
  }
  else{
    int val=s-&gt;arr[s-&gt;top];
    s-&gt;top--;;
    return val;
  }
}
int peek(struct stack *ptr,int i)
{
  if(ptr-&gt;top-i+1&lt;0)
  {
    printf("Your Enter position is Invalid");
    return -1;
  }
  else
  {
    return ptr-&gt;arr[ptr-&gt;top-i+1];
  }
}
int stacktop(struct stack *s)
{
  return s-&gt;arr[s-&gt;top];
}
int stackbottom(struct stack *s)
{
  return s-&gt;arr[0];
}
int main()
{
  struct stack *s=(struct stack*)malloc(sizeof(struct stack));
  s-&gt;size=8;
  s-&gt;top=-1;
  s-&gt;arr=(int*)malloc(s-&gt;size*sizeof(int));
  
  printf("empty=%d",empty(s));
  printf("full=%d",full(s));
    push(s,23);
      push(s,23);
        push(s,23);
          push(s,23);
            push(s,23);
              push(s,11);
                push(s,12);
                
                  push(s,3);
    printf("empty=%d",empty(s));
  printf("full=%d",full(s));
//  printf("Your %d is deleted",pop(s));
//  printf("Your %d is deleted",pop(s));
//  printf("Your %d is deleted",pop(s));
//  printf("Your %d is deleted",pop(s));
  int i;
  for(i=1;i&lt;=s-&gt;top+1;i++)
  {
    printf("\nThis %d position detail is %d",i,peek(s,i));
  }
  printf("\nEnter the topmost element in stack%d",stacktop(s));
  printf("\nEnter the bottommost element in stack%d",stackbottom(s));
return 0;
}</code></pre></br></br> 

<b class="tit">
Program 12:All stack operations in linked list like(empty(),full(),push(),pop(),peek(),stacktop(),stackbottom()).
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
  int data;
  struct node *next;
};
  struct node *top=NULL;
void display(struct node *top)
{
//  struct node *n=(struct node*)malloc(sizeof(struct node));
  while(top!=NULL)
  {
    printf("\nElement is=%d\n",top-&gt;data);
    top=top-&gt;next;
  }
}
int empty(struct node *top)
{
  if(top==NULL)
  {
    return 1;
  }
  else{
    return 0;
  }
}
int full(struct node *top)
{
  struct node *n=(struct node*)malloc(sizeof(struct node));
  
  if(n==NULL)
  {
    return 1;
  }
  else{
    return 0;
  }
}
struct node* push(struct node *top,int data)
{
  if(full(top))
  {
    printf("stack is overflow");
  }
  else
  {
  
  struct node *n=(struct node*)malloc(sizeof(struct node));
    
  n-&gt;data=data;
    n-&gt;next=top;
    top=n;
  return top;
}
}
void pop(struct node *tp)
{
  if(empty(top))
  {
    printf("stack is empty");
  }
  else
  {
  
//  struct node *n=(struct node*)malloc(sizeof(struct node));
    struct node *n=tp;
    top=tp-&gt;next;
    free(n);

}
}
int peek(struct node *top,int p)
{
  int i;
  for(i=0;(i&lt;p-1 && top!=NULL);i++)
  {
    top=top-&gt;next;
    
  }
  return top-&gt;data;
}
int stacktop(struct node *top)
{
  return top-&gt;data;
}
//int stackbottom(struct node *top)
//{
//  return top-&gt;data[0];
//}
int main()
{

  printf("empty=%d",empty(top));
  printf("full=%d",full(top));
  top=push(top,12);
    top=push(top,14);
      top=push(top,16);
//  pop(top);
  display(top);
  printf("Display the position of Element%d",peek(top,3));
  printf("Print the topmost element %d",stacktop(top));
//  printf("Print the bottommost element %d",stackbottom(top));
printf("empty=%d",empty(top));
  printf("full=%d",full(top));

return 0;
}</code></pre></br></br>

<b class="tit">
Program 13:Single parenthesis match in stack.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct stack{
  int size;
  int top;
  char *arr;
};

int empty(struct stack *ptr){
  if(ptr-&gt;top==-1)
  {
  
    return 1;
  }
  else{
    return 0;
  }
}
int full(struct stack *ptr){
  if(ptr-&gt;top==ptr-&gt;size-1)
  {
    return 1;
  }
  else{
    return 0;
  }
}
void push(struct stack *ptr,char val)
{
  ptr-&gt;top++;
  ptr-&gt;arr[ptr-&gt;top]=val;
}
char pop(struct stack *ptr)
{
  if(empty(ptr))
  {
    printf("This stack is empty");
    return -1;
  }
  else{
    char val=ptr-&gt;arr[ptr-&gt;top];
    ptr-&gt;top--;;
    return val;
  }
}
int parenthimatch(char * exp)
{
  struct stack *sp;
  sp-&gt;size=100;
  sp-&gt;top=-1;
  sp-&gt;arr=(char*)malloc(sp-&gt;size*sizeof(char));
  
  int i;
  for(i=0;exp[i]!='\0';i++)
  {
    if(exp[i]=='(')
    {
      push(sp,'(');
    }
    else if(exp[i]==')')
    {
      if(empty(sp))
      {
        return 0;
      }
      pop(sp);
    }
  }
if(empty(sp))
{
  return 1;
}
else{
  return 0;
}

}
int main()
{
  
char * exp="((8)8*5())()))";

if(parenthimatch(exp))
{
  printf("parenthis is balanced");
}
else
{
  printf("parenthis is not balanced");
}

return 0;
}</code></pre></br></br> 

<b class="tit">
Program 14:Multi parenthesis match in stack.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct stack{
  int size;
  int top;
  char *arr;
};

int empty(struct stack *ptr){
  if(ptr-&gt;top==-1)
  {
  
    return 1;
  }
  else{
    return 0;
  }
}
int full(struct stack *ptr){
  if(ptr-&gt;top==ptr-&gt;size-1)
  {
    return 1;
  }
  else{
    return 0;
  }
}
void push(struct stack *ptr,char val)
{
  ptr-&gt;top++;
  ptr-&gt;arr[ptr-&gt;top]=val;
}
char pop(struct stack *ptr)
{
  if(empty(ptr))
  {
    printf("This stack is empty");
    return -1;
  }
  else{
    char val=ptr-&gt;arr[ptr-&gt;top];
    ptr-&gt;top--;;
    return val;
  }
}
int match(char a,char b)
{
  if(a=='(' && b==')')
  {
    return 1;
  }
  if(a=='{' && b=='}')
  {
    return 1;
  }
  if(a=='[' && b==']')
  {
    return 1;
  }
  return 0;
}
int parenthimatch(char * exp)
{
  struct stack *sp;
  sp-&gt;size=100;
  sp-&gt;top=-1;
  sp-&gt;arr=(char*)malloc(sp-&gt;size*sizeof(char));
  char mat_exp;
  int i;
  for(i=0;exp[i]!='\0';i++)
  {
    if(exp[i]=='(' || exp[i]=='{' || exp[i]=='[')
    {
      push(sp,exp[i]);
    }
    else if(exp[i]==')' || exp[i]=='}' || exp[i]==']')
    {
      if(empty(sp))
      {
        return 0;
      }
      mat_exp=pop(sp);
      if(!match(mat_exp,exp[i]))
      {
        return 0;
      }
      
    }
  }
if(empty(sp))
{
  return 1;
}
else{
  return 0;
}

}
int main()
{
  
char * exp="[9[9[9}]]2";

if(parenthimatch(exp))
{
  printf("parenthis is balanced");
}
else
{
  printf("parenthis is not balanced");
}
return 0;
}</code></pre></br></br>

<b class="tit">
Program 15:Infix to postfix with stack program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
struct stack{
  int size;
  int top;
  char *arr;
};
int stacktop(struct stack *sp)
{
  return sp-&gt;arr[sp-&gt;top];
}
int empty(struct stack *ptr){
  if(ptr-&gt;top==-1)
  {
  
    return 1;
  }
  else{
    return 0;
  }
}
int full(struct stack *ptr){
  if(ptr-&gt;top==ptr-&gt;size-1)
  {
    return 1;
  }
  else{
    return 0;
  }
}
void push(struct stack *ptr,char val)
{
  ptr-&gt;top++;
  ptr-&gt;arr[ptr-&gt;top]=val;
}
char pop(struct stack *ptr)
{
  if(empty(ptr))
  {
    printf("This stack is empty");
    return -1;
  }
  else{
    char val=ptr-&gt;arr[ptr-&gt;top];
    ptr-&gt;top--;;
    return val;
  }
}
int precedune(char p)
{
  if(p=='*' || p=='/')
{
  return 3;
}
if(p=='+' || p=='-')
{
  return 2;
}
return 0;
}
int isoperator(char x)
{
  if(x=='*' || x=='/' || x=='+' || x=='-')
    return 1;
else
return 0;
}
char *infixtopostfix(char *infix)
{
  struct stack *sp=(struct stack*)malloc(sizeof(struct stack));
  sp-&gt;size=100;
  sp-&gt;top=-1;
  sp-&gt;arr=(char*)malloc(sp-&gt;size*sizeof(char));
  char *postfix=(char*)malloc(strlen(infix)+1*sizeof(char));
  int i=0;
  int j=0;
  while(infix[i]!='\0')
  {
    if(!isoperator(infix[i]))
    {
    postfix[j]=infix[i];
    i++;
    j++;
      }
      else{
        if(precedune(infix[i])&gt;precedune(stacktop(sp)))
        {
          push(sp,infix[i]);
          i++;
                } 
        else{
          postfix[j]=pop(sp);
          j++;
        }     
      }
  }
  while(!empty(sp))
  {
    postfix[j]=pop(sp);
    j++;
  }
  postfix[j]='\0';
  return postfix;
}
int main()
{
  
  char *infix="x*y/z+k";
  printf("Covert infix to postfix=%s",infixtopostfix(infix));
return 0;
}</code></pre></br></br> 

<b class="tit">
Program 16:Implementation in queue.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct queue{
  int size;
  int f;
  int b;
  int *arr;
};
int full(struct queue *p)
{
  if(p-&gt;b==p-&gt;size-1)
  return 1;
  else
  return 0;
}
int empty(struct queue *p)
{
  if(p-&gt;b==p-&gt;f)
  return 1;
  else
  return 0;
}
void enqueue(struct queue *p,int data)
{
  if(full(p))
  {
    printf("Queue is full");
  }
  else{
    p-&gt;b++;
    p-&gt;arr[p-&gt;b]=data;
  }
}
int dequeue(struct queue *p)
{
  int a=-1;
  if(empty(p))
  {
    printf("queue is empty");
  }
  else{
    p-&gt;f++;
    a=p-&gt;arr[p-&gt;f];
  }
  return a;
}
int main()
{

  struct queue p;
  p.size=3;
  p.f=p.b=-1;
  p.arr=(int*)malloc(p.size*sizeof(int));
if(empty(&p))
  {
    printf("queue is empty");
  }
  enqueue(&p,10);
  enqueue(&p,20);

  enqueue(&p,30);
  printf("\nThis %d element remove from queue",dequeue(&p));
printf("\nThis %d element remove from queue",dequeue(&p));
printf("\nThis %d element remove from queue",dequeue(&p));
if(full(&p))
  {
    printf("\nqueue is full");
  }
return 0;
}</code></pre></br></br>

<b class="tit">
Program 17:Linked list in queue.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
  int data;
  struct node *next;
};
struct node *f=NULL;
  struct node *b=NULL;
void linkedtravel(struct node *f)
{
  while(f!=NULL)
  {
    printf("\nElement is=%d",f-&gt;data);
    f=f-&gt;next;
  }
}
void enqueue(int val)
{
  struct node *n=(struct node*)malloc(sizeof(struct node));
  if(n==NULL)
  {
    printf("Queue is full");
    
  }
  else{
    n-&gt;data=val;
    n-&gt;next=NULL;
    if(f==NULL)
    {
      f=b=n;
    }
    else{
      b-&gt;next=n;
      b=n;
    }
  }
}
int dequeue()
{
  struct node *n=f;
  int val=-1;
  if(f==NULL)
  {
    printf("Queue is empty");
  }
  else{
    val=n-&gt;data;
    f=f-&gt;next;
    free(n);
  }
return val;
}
int main()
{
  
  enqueue(10);
enqueue(20);
enqueue(30);
linkedtravel(f);
printf("\nRemove %d element from queue",dequeue());
printf("\nRemove %d element from queue",dequeue());
printf("\nRemove %d element from queue",dequeue());
printf("\nRemove %d element from queue",dequeue());
return 0;
}</code></pre></br></br>

<b class="tit">
Program 18:Bubble short program with adaptive.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void printarr(int *a,int n)
{
  int i;
  for(i=0;i&lt;n;i++)
  {
    printf("%d ",a[i]);
  }
  printf("\n");
}
void bubblesort(int *a,int n)
{
  int i,j,temp;
  int adop=0;
  for(i=0;i&lt;=n-1;i++)
  {
    printf("%d tiems pass array\n",i+1);
    adop=1;
    for(j=0;j&lt;n-1-i;j++)
    {
      if(a[j]&gt;a[j+1])
      {
        temp=a[j];
        a[j]=a[j+1];
        a[j+1]=temp;
        adop=0;
        } 
    }
    if(adop)
    {
      return;
    }
  }
}
int main()
{
  int a[]={6,5,4,3,2,1};
  int n=6;
  printarr(a,n);
  bubblesort(a,n);
  printarr(a,n);
return 0;

}</code></pre></br></br> 

<b class="tit">
Program 19:Insertion sort program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void printarr(int *a,int n)
{
  int i;
  for(i=0;i&lt;n;i++)
  {
    printf("%d ",a[i]);
  }
  printf("\n");
}
void insertionsort(int *a,int n)
{
  int i,key,j;
  for(i=0;i&lt;=n-1;i++)
  {
    key=a[i];
    j=i-1;
    while(j&gt;=0 && a[j]&gt;key)
    {
      a[j+1]=a[j];
      j--;
    }
    a[j+1]=key;
  }
}
int main()
{
  int a[]={74,2,62,25,84};
  int n=5;
  printarr(a,n);
  insertionsort(a,n);
  printarr(a,n);
return 0;
}</code></pre></br></br>

<b class="tit">
Program 20:Selection sort program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void printarr(int *a,int n)
{
  int i;
  for(i=0;i&lt;n;i++)
  {
    printf("%d ",a[i]);
  }
  printf("\n");
}
void selectionsort(int *a,int n)
{
  int i,indexofmin,j,temp;
  for(i=0;i&lt;n-1;i++)
  {
    indexofmin=i;
    for(j=i+1;j&lt;n;j++)
    {
      if(a[j]&lt;a[indexofmin])
      {
        indexofmin=j;
      }
    }
    temp=a[i];
    a[i]=a[indexofmin];
    a[indexofmin]=temp;
  }
}
int main()
{
  int a[]={6,5,4,3,2};
  int n=5;
  printarr(a,n);
  selectionsort(a,n);
  printarr(a,n);


return 0;

}</code></pre></br></br> 

<b class="tit">
Program 21:Quick sort program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void printarr(int *a,int n)
{
  int i;
  for(i=0;i&lt;n;i++)
  {
    printf("%d ",a[i]);
  }
  printf("\n");
}
int partition(int *a,int low,int high)
{
  int pivot=a[low];
  int temp,i,j;
  i=low+1;
  j=high;
do{
  
  while(a[i]&lt;=pivot)
  {
    i++;
  }
  while(a[j]&gt;pivot)
  {
    j--;
  }
  if(i&lt;j)
  {
    temp=a[i];
    a[i]=a[j];
    a[j]=temp;
  }
}while(i&lt;j);
temp=a[low];
a[low]=a[j];
a[j]=temp;
return j;
}

void quicksort(int *a,int low,int high)
{
  int partitionindex;
  if(low&lt;high)
  {
      partitionindex=partition(a,low,high);
      quicksort(a,low,partitionindex-1);
      quicksort(a,partitionindex+1,high);
  }
} 
int main()
{
  int a[]={5,1,9,15,3412,1452,3954,562};
  int n=8;
  printarr(a,n);
  quicksort(a,0,n-1);
  printarr(a,n);


return 0;

}</code></pre></br></br>

<b class="tit">
Program 22:Merge sort program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
void printarr(int *a,int n)
{
  int i;
  for(i=0;i&lt;n;i++)
  {
    printf("%d ",a[i]);
  }
  printf("\n");
}
void merge(int *a,int low,int mid,int high)
{
  int b[100];
  int i=low,j=mid+1,k=low;
  
  while(i&lt;=mid && j&lt;=high)
  {
    if(a[i]&lt;a[j])
    {
      b[k]=a[i];
      i++;
      k++;
    }
    else{
      b[k]=a[j];
      j++;
      k++;
    }
  }
  while(i&lt;=mid)
  {
    b[k]=a[i];
    k++;
    i++;
  }
    while(j&lt;=high)
  {
    b[k]=a[j];
    j++;
    k++;
  }
  for(i=low;i&lt;=high;i++)
  {
    a[i]=b[i];
  }
}
void mergesort(int *a,int low ,int high)
{
  int mid;
  mid=(low+high)/2;
  if(low&lt;high)
  {
    mergesort(a,low,mid);
    mergesort(a,mid+1,high);
    merge(a,low,mid,high);
  }
}
int main()
{
  int a[]={1,56,4,49,461,423};
  int n=6;
  printarr(a,n);
  mergesort(a,0,n-1);
  printarr(a,n);


return 0;

}</code></pre></br></br>

<b class="tit">
Program 23:Count sort program.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;limits.h&gt;
#include&lt;stdlib.h&gt;
void printarr(int *a,int n)
{
  int i;
  for(i=0;i&lt;n;i++)
  {
    printf("%d ",a[i]);
  }
  printf("\n");
}
int maximum(int *a,int n)
{
  int i;
  int max=INT_MIN;
  for(i=0;i&lt;n;i++)
  {
    if(max&lt;a[i])
    {
    max=a[i]; 
    }
  }
  return max;
}
countsort(int *a,int n)
{
  int i,j;
  int max=maximum(a,n);
  int *count;
  count=(int*)malloc(max+1*sizeof(int));
  for(i=0;i&lt;=max;i++)
  {
    count[i]=0;
  }
  
  for(i=0;i&lt;n;i++)
  {
    count[a[i]]=count[a[i]]+1;
  }
  i=0;
  j=0;
  while(i&lt;=max)
  {
    if(count[i]&gt;0)
    {
      a[j]=i;
      count[i]=count[i]-1;
        j++;  }
    else{
      i++;
    }
  }
}
int main()
{
  int a[]={5,12,16,116,34,1
  };
  int n=6;
  printarr(a,n);
  countsort(a,n);
  printarr(a,n);


return 0;

}</code></pre></br></br> 

<b class="tit">
Program 24:Binary tree representation in linked list(preorder,postorder,inorder).
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
  int data;
  struct node *left;
  struct node *right;
};
struct node *createnode(int data)
{
  struct node *n;
  n=(struct node*)malloc(sizeof(struct node));
  n-&gt;data=data;
  n-&gt;left=NULL;
  n-&gt;right=NULL;
  return n;
}
void preorder(struct node  *root)
{
  if(root!=NULL)
  {
    printf("%d ",root-&gt;data);
    preorder(root-&gt;left);
    preorder(root-&gt;right);
  }
  
}
void postorder(struct node *root)
{
  if(root!=NULL)
  {
    postorder(root-&gt;left);
    postorder(root-&gt;right);
    printf("%d ",root-&gt;data);
  }
}
void inorder(struct node *root)
{
  if(root!=NULL)
  {
    inorder(root-&gt;left);
    printf("%d ",root-&gt;data);
    inorder(root-&gt;right);
  }
}
int main()
{
  struct node *p=createnode(1);
  struct node *p1=createnode(2);
  struct node *p2=createnode(3);
  struct node *p3=createnode(4);
  struct node *p4=createnode(5);
  
  p-&gt;left=p1;
  p-&gt;right=p2;
  p1-&gt;left=p3;
  p1-&gt;right=p4;
  
    preorder(p);
    printf("\n");
postorder(p);
  printf("\n");
inorder(p);
return 0;

}</code></pre></br></br>

<b class="tit">
Program 25:Binary search tree(BST) insertion.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
  int data;
  struct node *left;
  struct node *right;
};
struct node *createnode(int data)
{
  struct node *n;
  n=(struct node*)malloc(sizeof(struct node));
  n-&gt;data=data;
  n-&gt;left=NULL;
  n-&gt;right=NULL;
  return n;
}
void insert(struct node *root,int key)
{
  struct node *prev=NULL;
  while(root!=NULL)
  {
    prev=root;
      if(key=root-&gt;data)
      {
        printf("Cannot Insert");
        return;
      }
      else if(key&lt;root-&gt;data)
      {
        root=root-&gt;left;
      }
      else
    {
      root=root-&gt;right;
    }
  }
  struct node *new=createnode(key);
  if(key&lt;prev-&gt;data)
  {
    prev-&gt;left=new;
  }
  else
  {
    prev-&gt;right=new;
  }
}
int main()      
{
  struct node *p=createnode(5);
  struct node *p1=createnode(3);
  struct node *p2=createnode(6);
  struct node *p3=createnode(1);
  struct node *p4=createnode(4);
//   5
//  / \
//  3 6
//  /\
  1 4
  p-&gt;left=p1;
  p-&gt;right=p2;
  p1-&gt;left=p3;
  p1-&gt;right=p4;
  
  insert(p,16);
printf("Insert the=%d",p-&gt;right-&gt;right-&gt;data);

return 0;

}</code></pre></br></br> 

<b class="tit">
Program 26:Searching tree with recursion.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
  int data;
  struct node *left;
  struct node *right;
};
struct node *createnode(int data)
{
  struct node *n;
  n=(struct node*)malloc(sizeof(struct node));
  n-&gt;data=data;
  n-&gt;left=NULL;
  n-&gt;right=NULL;
  return n;
}
//struct node *recursearch(struct node *root,int key)
//{
//  if(root==NULL)
//  {
//    return NULL;
//  }
//  if(key==root-&gt;data)
//  {
//    return root;
//  }
//  if(key&lt;=root-&gt;data)
//  {
//    return recursearch(root-&gt;left,key);
//    
//  }
//  if(key&gt;=root-&gt;data)
//  {
//    return recursearch(root-&gt;right,key);
//  }
//
//}
struct node *recursearch(struct node *root,int key)
{
  while(root!=NULL) 
  {
  if(key==root-&gt;data)
  {
    return root;
  }
  if(key&lt;=root-&gt;data)
  {
    root=root-&gt;left;   
  }
  if(key&gt;=root-&gt;data)
  {
    root=root-&gt;right;
  }
}
  return NULL;

}
int main()
{
  struct node *p=createnode(5);
  struct node *p1=createnode(2);
  struct node *p2=createnode(6);
  struct node *p3=createnode(1);
  struct node *p4=createnode(4);
  
  p-&gt;left=p1;
  p-&gt;right=p2;
  p1-&gt;left=p3;
  p1-&gt;right=p4;
  
  printf("\n");
//inorder(p);
printf("\n");
struct node *n=recursearch(p,62);
if(n!=NULL)
{
  printf("found: %d",n-&gt;data);
}
else{
  printf("Searching elemnent is not in BST...");
}
return 0;

}</code></pre></br></br>

<b class="tit">
Program 27:Try to inorder function to BT is BST?
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node{
  int data;
  struct node *left;
  struct node *right;
};
struct node *createnode(int data)
{
  struct node *n;
  n=(struct node*)malloc(sizeof(struct node));
  n-&gt;data=data;
  n-&gt;left=NULL;
  n-&gt;right=NULL;
  return n;
}
int isbst(struct node *root)
{
  static struct node *prev=NULL;
    if(root!=NULL)
    {
      if(!isbst(root-&gt;left))
      {
        return 0;
        } 
        if(prev!=NULL && root-&gt;data &lt;= prev-&gt;data)
        {
          return 0;
        }
        prev=root;
        return isbst(root-&gt;right);
    }
    else{
      return 1;
    }
}
int main()
{
  struct node *p=createnode(5);
  struct node *p1=createnode(2);
  struct node *p2=createnode(6);
  struct node *p3=createnode(1);
  struct node *p4=createnode(4);
  
  p-&gt;left=p1;
  p-&gt;right=p2;
  p1-&gt;left=p3;
  p1-&gt;right=p4;
  
  printf("\n");
//inorder(p);
printf("\n");
printf("%d ",isbst(p));
return 0;

}</code></pre></br></br>

<b class="tit">
Program 28:Reverse array first method.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;

void display(int arr[],int size)
{
  int i;
  for(i=0;i&lt;size;i++)
  {
    printf("%d\n",arr[i]);
  }
}
void reverse(int arr[],int size)
{
  int i;
  for(i=size-1;i&gt;=0;i--)
  {
    printf("%d\n",arr[i]);
  }
}
int main()
{

int arr[]={1,2,3};
int size=3;
printf("Display the array\n");
display(arr,size);
printf("Display the reverse array\n");
reverse(arr,size);

return 0;

}</code></pre></br></br>

<b class="tit">
Program 29:Reverse method second method.
  
</b>

  <pre class="language-c"><code class="dec">#include&lt;stdio.h&gt;
int reverse(int arr[],int size)
{
  int i;
  for(i=0;i&lt;size;i++)
  { 
    int temp=0;
    temp=arr[i];
    arr[i]=arr[(size-1)-i];
    arr[(size-1)-i]=temp;
  } 
}
int display(int arr[],int size)
{
  int i;
  for(i=0;i&lt;size;i++)
  {
    printf("%d\n",arr[i]);
  }
}

int main()

{
  
  int arr[]={1,3,5};
  int size=3;
  display(arr,size);
  reverse(arr,size);
  display(arr,size);


return 0;

}</code></pre></br></br>





</div>

  
</div>
{% else %}
<div class="container" style="margin:50px;margin-right:150px;  ">
<h1 style="background:#ccc;padding:30px;margin:100px 80px;font-weight:bold;margin-left:30px;">You are not logged in! Please   login to see a cheat sheet.</h1>
</div>
{% endif %}
{% endblock body %}
